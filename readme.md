## Thoughts

Codebases should be set up with developer happiness in mind, with code being written simply, concise and easy to understand.

## Setup instructions

```bash
npm install # installs all dependencies
npm run seed # seeds the database (Please make sure you have mongodb running on localhost:27017)
npm run dev # starts the server with nodemon
npm run lint # runs eslint on the codebase
```

## Packages used

```bash
Express # web framework
Mongoose # ORM
Morgan # logging
Express-rate-limit # rate limiting
Helmet # security
Jsonwebtoken # JWT
Eslint # linting
Validator # MongoDB validation
Bcrypt # password hashing
Dotenv # environment variables
```

## Code implementation

The codebase is organized in a way that makes it easy to understand and maintain. The codebase is split into 3 main folders:

controllers - contains all the controllers

models - all the models

routes - all the routes

Any reusable utils for would have been under the utils folder or a separate package, and tests would have been under the tests folder or alongside the files they test for. eg file.js & file.test.js, this would ensure the project is easy to maintain and extend.

While there may be duplication of code, it is important to keep in mind that duplication is far cheaper than the wrong abstraction. Also the codebase is small enough that duplication is not a problem.

## Security

The app uses helmet to set security related HTTP headers, and express-rate-limit to limit repeated requests. JWT is used for authentication and authorization, and bcrypt is used to hash passwords. The user's role is also stored in the JWT, and is used to authenticate the user and authorize the user to perform certain actions.

## Environment variables

Env variables are stored in a .env file, and are loaded using dotenv. For ease of use, a .env file is committed to the repo, but in a real world scenario, this would not be the case.

## Linting

Eslint is used to lint the codebase, the style is the default eslint:recommended style, with a few rules changed to suit the project. The rules can be found in the .eslintrc.json file.

## API documentation

The API documentation can be found at [https://documenter.getpostman.com/view/490308/2s8YzQW3vN](https://documenter.getpostman.com/view/490308/2s8YzQW3vN)
, However imho the best way to understand an api is to read the code and try it, so the API can be tested using the postman collection included in the repo.

## API endpoints

/healtcheck - GET - returns a 200 status code if the server is up, this is used by the load balancer to check if the server is up

/api/v1 is the base url for all the endpoints. This is used to version the api, and to make it easy to add new versions of the api in the future.

/api/v1/auth This is the base url for all the authentication and authorization endpoints

/api/v1/auth/books This is the base url for all the books CRUD endpoints, and also borrowing and returning books.

/api/v1/auth/users This is the base url for all the users CRUD endpoints and for admins to approve user creation or change requests

It is important to note that the some of the /api/v1/auth/books and /api/v1/auth/users endpoints are protected, and require a valid JWT to be passed in the Authorization header. The JWT is generated by the /api/v1/auth/login endpoint.

Seeding should populate the database with 2 admin users, 1 editor user and 1 mamber user. There will also be some books in the database. The passwords for all the users are "test1234".

## API Design

The API is designed to be RESTful, and to follow the principles of REST. It is designed to be scalable, secure and easy to use.

## Middleware

Authentication and authorization is done using JWT and passed in via middleware. The JWT is generated by the /api/v1/auth/login endpoint. The JWT is passed in the Bearer token in the Authorization header. Third party middleware is used to rate limit requests, and to set security related HTTP headers.

## Scalability

The app can be scaled horizontally by adding more servers. It can also be scaled vertically by adding more resources to the server. It also can be scaled by adding more databases, and using a load balancer to distribute the load.

## Checklist - Codebase

- [x] For Node.js,use Express.js. For Python, use Flask or FastAPI.
- [x] CRUD of user objects
- [x] CRUD of book objects
- [x] Borrowing and returning of books
- [x] Code formatting and linting
- [x] README file for setup instructions
- [x] A maker checker rule for adding, removing and updating users (i.e. an Admin changes to add/remove/update users will only be finalised after approved by another Admin).

## Checklist - Readme

- [x] How you structured your project
- [x] How you designed the APIs
- [x] The code implementation
- [x] Scalability of your project

## Future possible extensions

- Search books by author, category, ISBN etc
- Search users by name, email, role
- History of borrowings, an audit log
- Pagination
- Unit tests
